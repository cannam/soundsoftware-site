<% events = @events_by_day %>
<% max = 5 %>
<% if (events.nil?) 
     activity = Redmine::Activity::Fetcher.new(User.current)
     events = activity.events(Date.today - 14, Date.today + 1)
   end
%>

<% if events.empty? %>

<% else %>

   <ul>

   <% 
      # Transform events list into hash from project id to number of
      # occurrences of project in list (there is surely a tidier way
      # to do this, e.g. chunk() in Ruby 1.9 but not in 1.8)
      phash = events.map { |e| e.project unless !e.respond_to?(:project) }.sort.group_by { |p| p.id }
      phash = phash.merge(phash) { |k,v| v.length }
      threshold = phash.values.sort.last(max).first
      busy = phash.keys.select { |k| phash[k] >= threshold }.sample(max)

      for id in busy
        project = Project.find(id)
   %>

   <li class="busy">
     <span class="title">
       <% if !project.root? %>
         <% project.ancestors.each do |p| %>
           <%= h(p) %>&nbsp;&#187;
         <% end %>
       <% end %>
       <%= link_to_project project %>
     </span>
     <% if !project.is_public? %>
       <span class="private"><%= l(:field_is_private) %></span>
     <% end %>
     <span class='managers'>
     <%
	u = project.users_by_role
	if ! u.empty? %>
     (<%=
	   mgmt_roles = u.keys.select{ |r| r.allowed_to?(:edit_project) }
	   managers = mgmt_roles.map{ |r| u[r] }.flatten.sort.uniq
	   managers.map{ |m| m.name }.join(', ')
	 %>)<%
	end
	%>
	</span>

     <%= render_project_short_description project %>
   </li>

    <% end %>
  </ul>
<% end %>
